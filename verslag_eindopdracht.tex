\documentclass[a4paper]{article}

\usepackage{xcolor}
\usepackage{fancyheadings}
\usepackage{booktabs}
\usepackage{enumitem}

\newcommand{\todo}[1]{\textcolor{red}{[#1]}}
\newcommand{\1}[0]{\'{e}\'{e}n}

\renewcommand\labelitemi{-}
\renewcommand{\figurename}{Figuur}
\renewcommand{\tablename}{Tabel}

\lhead{Open Universiteit}
\chead{IM0102, Design patterns}
\rhead{Eindopdracht}

\begin{document}
\pagestyle{fancy}

\section*{Studentgegevens}
\begin{description}
	\item [Cursuscode] IM0102
	\item JabberPoint
    \item Jan Jaap Sandee --- 852025385
	\item Gerralt Gottemaker --- 852083852
\end{description}
\todo{Verslag op taal- en spellingsfouten controleren}

\section*{Aanpak}
Om de opdracht succesvol af te ronden, is het zaak om goed samen te werken. We hebben het geluk collega's te zijn, wat het communiceren een aanzienlijk stuk gemakkelijker maakt. In dit hoofdstuk staat de aanpak beschreven die we gekozen hebben. De volgorde waarin het opgeschreven is, is ook de volgorde waarin we gewerkt hebben. Verder staat per item beschreven wie hieraan gewerkt heeft. Als niet vermeld wordt wie eraan gewerkt heeft, hebben beide teamgenoten eraan gewerkt.

Er is begonnen met het opzetten van een Git repository waarin Jan Jaap Gerralt en beide examinatoren heeft toegevoegd. Hier is vervolgens de beginsituatie van JabberPoint toegevoegd. Even later is hier ook een begin van het verslag en een TODO lijst aan toegevoegd. Het verslag is toegevoegd omdat het een LaTeX bestand is, welke prima door versiebeheer beheerd kan worden. Verder heeft Gerralt een Google Drive folder gemaakt en Jan Jaap uitgenodigd. Hier zullen diagrammen (met Draw.io) en andere belangrijke bestanden die niet geschikt zijn voor Git versiebeheer worden bijgehouden. Als laatst heeft Gerralt een Project Board aangemaakt waar overzichtelijk de TODO's wat betreft code en documentatie bijgehouden kunnen worden.

Hierna heeft Jan Jaap een eenvoudig diagram gemaakt van de huidige situatie van JabberPoint. Dit geeft een duidelijker beeld van de pijnpunten en maakt de geplande refactoring overzichtelijker.

Vervolgens is er een Probleem Analyse gemaakt waarbij alleen is gekeken naar de functionaliteit van het systeem. De zogenaamde Mankala aanpak staat hierbij centraal. Gedurende het maken van de analyse is nog niet gekeken naar bestaande code van JabberPoint, om zo vooroordelen uit te sluiten. Hier is bewust voor gekozen omdat we het idee hebben dat het zo gemakkelijker is om te denken in termen van het domein en niet direct te denken in klassenamen. Jan Jaap heeft hiervan het opzetje gemaakt, welke vervolgens uitgebreid is door Gerralt. Hierna is samen gewerkt aan de uiteindelijke versie van de probleemanalyse.

Aan de hand van de probleemanalyse is een klassendiagram opgebouwd. Hierbij zijn de principes die genoemd worden in het tekstboek gevolgd, waarbij erg gelet is op het principe dat patterns de context creÃ«ren van onderliggende patterns. De design principes zoals high cohesion en low coupling staan hierbij natuurlijk ook centraal. In het verslag zijn vervolgens de verschillende (belangrijke) classes en structuren toegelicht.
\\\\
\todo{Aanpak keuzen verantwoorden}
\\
\todo{Aanpak implementatie verantwoorden}


\section{Probleemanalyse}
Om JabberPoint goed te kunnen refactoren, is een probleemanalyse van de casus gemaakt. Deze probleemanalyse is op basis van de Mankala aanpak gedaan. Deze aanpak bestaat uit een aantal stappen, welke een steeds duidelijker beeld van het domein moeten opleveren. In de volgende koppen staan deze stappen uitgewerkt.

\subsection{Dingen}
We beginnen met het vastleggen van de entiteiten van het domein. Deze entiteiten, of "dingen", worden opgesomd in Tabel \ref{table:dingen}. De entiteiten die daar genoemd worden, zijn de entiteiten die van belang zijn voor het domein. Entiteiten die te maken hebben met de gebruikersinterface worden hier niet genoemd.
\begin{table}[!h]
\centering
	\begin{tabular}{lcl}
	\toprule
 	Concept & Sub-concept & Uitleg \\ \midrule
 	JabberPoint & - & Het programma. Kan presentaties afspelen.\\
 	Presentatie & - & Een enkele presentatie. Bevat slides.\\
 	Slide & - & Een pagina. Bevat elementen en een titel.\\
 	Element & Tekst & Bevat tekst voor op een slide.\\
 	 & Afbeelding & Bevat een afbeelding voor een slide.\\
 	Level & - & Het level van een element bepaalt wie de ouder is.\\
 	Stijl & - & Bevat info over het uiterlijk van een element.\\
 	Bestand & XML & Formaat waarin presentaties opgeslagen worden.\\
 	\bottomrule
	\end{tabular}
\caption{Lijst van entiteiten (dingen) binnen het domein.}
\label{table:dingen}
\end{table}
\\
Op het moment zijn er twee typen elementen: elementen die tekst bevatten en elementen die een afbeelding bevatten. Om het systeem zo flexibel mogelijk te maken, zal in het ontwerp rekening gehouden moeten worden met elementen met andere typen. Zo is het bijvoorbeeld denkbaar dat er in de toekomst een video element toegevoegd moet worden of iets dergelijks.
\\\\
Verder is het belangrijk om andere bestandsformaten alvast te ondersteunen in het ontwerp. Hierdoor behoudt het systeem zijn flexibiliteit. Op het moment wordt alleen XML ondersteund voor zowel het wegschrijven als het lezen. Echter zal in het ontwerp dus rekening gehouden worden met later toe te voegen bestandsformaten zoals JSON. Deze bestandsformaten zullen niet toegevoegd worden in zowel ontwerp als implementatie, echter zullen we bij de keuzen toelichten hoe we wel rekening houden met deze formaten.

\subsection{Acties}
Om de acties binnen het domein te kunnen gebruiken voor de analyse en het klassendiagram, is bepaalde informatie nodig. Om deze informatie te vergaren, wordt per actie de volgende vragen beantwoord:
\begin{itemize}[noitemsep]
\item Wie of wat heeft het initiatief om de actie te starten?
\item Aan welke regels moet voldaan worden voordat de actie uitgervoerd kan worden?
\item Wie of wat is gerelateerd aan de actie?
\item Is er aanvullende informatie nodig om de actie te kunnen uitvoeren?
\end{itemize}

In principe geldt voor elke actie dat het initiatief in de handen van de gebruiker ligt. Deze zal elke actie starten middels de grafische user interface (GUI). Echter zullen we bij het beantwoorden van de vraag ervan uitgaan dat de gebruiker de betreffende actie al begonnen is. Het initiatief ligt daarom bij de klasse / subroutine binnen het softwaresysteem en deze wordt dan ook genoemd. Om dezelfde reden wordt ook de GUI niet bij elk punt genoemd. Het moge echter duidelijk zijn dat de GUI voor de aansturing van het functionele deel van JabberPoint zorgt.

Deze sectie is vrij uitgebreid met als simpele reden dat deze sectie in principe de gehele functionele werking van JabberPoint toelicht. Hierdoor hoeft er in hoofdstuk \ref{sec:source} alleen aandacht besteed te worden aan de technische werking van het programma.

\subsubsection{Programma starten}
Wanneer het programma wordt gestart, zal JabberPoint opgestart worden met bepaalde standaard waarden. Bovenop JabberPoint zal een grafische user interface (GUI) gebouwd worden. Hoe de GUI communiceert met JabberPoint, is te vinden in hoofdstuk \ref{sec:ontwerp}. Om deze actie uit te voeren, is het aan te raden om een bestandsnaam mee te geven in de parameters. Wanneer dit niet gebeurt, zal het systeem opstarten met een standaard presentatie. Als aanvullende informatie is het goed om te weten dat de GUI hier los gezien moet worden van JabberPoint. JabberPoint is dus het functionele deel van het programma.

\subsubsection{Presentatie openen}
\label{subsub:presOpenen}
De tweede actie is het openen van een presentatie. De actie wordt gestart door het afhandelen van een gebeurtenis uit het menu en zal door moeten druppelen naar het functionele deel van JabberPoint. De actie wordt gestart door het afhandelen van een gebeurtenis uit het menu en zal door moeten druppelen naar het functionele deel van JabberPoint. JabberPoint en de Presentatie zijn gerelateerd aan deze actie. Verder moet genoemd worden dat momenteel geen bestand van het systeem gekozen kan worden. JabberPoint zal dus een standaard bestand (test.xml) openen. In het ontwerp zal wel rekening gehouden worden met een mogelijke uitbreiding om meerdere bestandsformaten te ondersteunen.

\subsubsection{Nieuwe presentatie starten}
De volgende actie is het starten van een nieuwe presentatie. Deze presentatie is volledig leeg. Wat het starten van de actie en de gerelateerde entiteiten betreft, geldt hetzelfde als bij de actie Presentatie openen. Het is verder goed om te noemen dat het starten van een nieuwe presentatie relatief weinig nut heeft. Er is immers geen functionaliteit om de presentatie aan te passen via de GUI.

\subsubsection{Presentatie opslaan}
Verder kunnen presentaties worden opgeslagen. Het gaat dan om de presentatie die op dat moment getoond wordt door de GUI. Deze actie wordt wederom gestart door het menu en ook hier geldt dat de actie door moet druppelen naar het functionele deel. Het opslaan lukt alleen als er een presentatie geopend is. Gelukkig is er altijd een presentatie geopend, dus dit mag geen problemen opleveren. Ook hier geldt dat JabberPoint, de Presentatie en het bestandsformaat gerelateerd zijn. Verder moet worden opgemerkt dat er geen feedback gegeven wordt wanneer het opslaan lukt. Dit is echter puur functioneel. Het zal dus niet in het ontwerp terug komen, maar wel in de implementatie. Ook hier wordt in het ontwerp rekening gehouden met eventuele later toe te voegen bestandsformaten anders dan XML.

\subsubsection{Slide weergeven}
\label{subsub:slideTonen}
Wanneer het programma wordt gestart, wordt een presentatie geopend (zie kopje \ref{subsub:presOpenen}). Wanneer dit gebeurt, wordt de eerste slide van deze presentatie weergegeven op het scherm. In eerste instantie wordt alleen de titel van deze slide weergegeven. Hoe de overige items op het scherm moeten komen, wordt geschreven in een aantal van de volgende kopjes. Deze actie is dus gerelateerd van de actie welke het openen van een presentatie beschrijft. Ook JabberPoint en de Presentatie zijn gerelateerd. Verder gelden er enkele regels waar eerst aan voldaan moet worden voordat deze actie uitgevoerd kan worden. Deze regels worden in paragraaf \ref{sub:regels} genoemd.

\subsubsection{Volgende item van slide weergeven}
\label{subsub:volgendeItem}
Dit is een van de acties die voortkomt uit de Feature request. Wanneer er op het pijltje naar beneden gedrukt wordt, zal het volgende item worden weergegeven. Hoe het item wordt weergegeven, hangt volledig af van de Stijl van een item. Alleen level 1 items zullen deze actie ondersteunen. Alle onderliggende items van level 1 items worden tegelijkertijd getekend op het moment dat deze actie uitgevoerd wordt. Wanneer deze actie vervolgens nog een keer uitgevoerd wordt, wordt het volgende level 1 item plus onderliggende items getekend. Gerelateerd aan deze actie zijn de entiteiten JabberPoint, de Presentatie, Slide, item (Element) en Stijl. Verder is de actie uit kopje \ref{subsub:volgendeSlide} gerelateerd.

\subsubsection{Laatste item van slide verbergen}
\label{subsub:vorigeItem}
Ook deze actie komt voort uit de Feature request en hangt nauw samen met de vorige actie. Wanneer er op het pijltje naar boven wordt gedrukt, wordt het laatst verschenen level 1 item weer verborgen. Ook hier geldt dat alle onderliggende items (de kinderen van het betreffende level 1 item) worden verborgen. Gerelateerd aan deze actie zijn JabberPoint, de Presentatie, Slide en item (Element). Ook hier geldt dat er een andere actie gerelateerd is, namelijk de actie uit kopje \ref{subsub:vorigeSlide}.

\subsubsection{Alle items van slide in \1 keer tonen}
\label{subsub:alleItems}
Het is ook mogelijk om alle items van een bepaalde slide in \1 keer te tonen. Wederom gaat het hier om een actie die voortkomt uit de Feature request. Wanneer op het pijltje naar rechts gedrukt wordt, worden alle nog verborgen items van een slide allemaal weergegeven. In principe is dit niets anders dan een aantal keer de actie van kopje \ref{subsub:volgendeItem} aanroepen. Daarom geldt dat alle gerelateerde regels en entiteiten hetzelfde zijn.

\subsubsection{Alle items van slide in \1 keer verbergen}
De laatste actie die uit de Feature request komt is het in \1 keer verbergen van alle op dat moment zichtbare items. Deze actie wordt uitgevoerd wanneer er op het pijltje naar links gedrukt wordt. Net als bij de vorige actie, geldt hier dat deze actie niets anders is dan een aantal keer een bepaalde actie uitvoeren, namelijk de actie van kopje \ref{subsub:vorigeItem}. Ook hier geldt daarom dat alle gerelateerde regels en entiteiten hetzelfde zijn.

\subsubsection{Volgende slide}
\label{subsub:volgendeSlide}
Naar de volgende slide gaan is de volgende actie. Deze actie zal gestart worden wanneer het volgende item van de slide weergegeven moet worden, maar deze niet meer beschikbaar is. Wanneer dit gebeurt, zal er gekeken worden of er nog een slide beschikbaar is. Mocht dit het geval zijn, zal deze worden getoond zoals beschreven in het kopje \ref{subsub:slideTonen}. Vervolgens kan de actie uit het kopje \ref{subsub:volgendeItem} gebruikt worden om de items te tonen of de actie uit kopje \ref{subsub:alleItems} om alle items in \1 keer te tonen. Deze actie moet dus, voordat het uitgevoerd kan worden, aan bovenstaande regels voldoen. De bovengenoemde acties zijn dus gerelateerd aan deze actie. Ook de GUI en de entiteiten JabberPoint en de Presentatie zijn gerelateerd.

\subsubsection{Vorige slide}
\label{subsub:vorigeSlide}
Naast naar de volgende slide gaan is de tegenovergestelde actie ook mogelijk. Wanneer de actie uit kopje \ref{subsub:vorigeItem} (vorige item) uitgevoerd wordt zonder dat er nog items op het scherm zichtbaar zijn, wordt er naar de vorige slide genavigeerd. Hierbij moet aan de regel voldaan worden dat er een vorige slide beschikbaar is. Mocht er niet aan deze regel voldaan worden, zal de actie simpelweg niet uitgevoerd worden. De genoemde regel is gerelateerd aan deze actie, evenals de genoemde actie. Verder zijn de entiteiten JabberPoint, Presentatie en Slide gerelateerd.

\subsubsection{Naar specifieke slide}
Ook is het mogelijk om rechtstreeks naar een specifieke slide te navigeren. De GUI zal vragen om een getal, welke vervolgens gecontroleerd wordt. Als blijkt dat de gebruiker een ongeldig getal heeft ingevuld (ongeldig betekent lager dan 1 of hoger dan het aantal slides), wordt de actie niet uitgevoerd. Mocht het een geldig getal betreffen, zal het systeem de juiste slide tonen zoals beschreven in het kopje \ref{subsub:slideTonen}. Deze actie is dan ook gerelateerd. Verder zijn de entiteiten JabberPoint, Presentatie en Slide gerelateerd, evenals de bovengenoemde regel.

\subsubsection{Informatie "Over / about" weergeven}
Als laatst is het mogelijk om bepaalde auteurs- en versieinformatie te tonen. Dit zal gedaan worden via het menu van de GUI. De GUI zal vragen aan JabberPoint wat de te tonen informatie is en deze tonen. Daarom is alleen de entiteit JabberPoint gerelateerd. Er is verder geen informatie nodig om deze actie uit te voeren. 

\subsection{Regels}
\label{sub:regels}

Er zijn regels waar bepaalde acties aan moeten voldoen voordat de betreffende actie uitgevoerd mag worden. Ook zijn er regels waar het hele systeem aan moet voldoen om succesvol uitgevoerd te kunnen worden. Verder zijn er voor deze opdracht ook relevante regels waar de gebruikersinterface mee te maken krijgt. Al deze regels zijn opgesomd in Tabel \ref{table:regels}. Elke regel bevat ook een korte beschrijving.

\begin{table}[!h]
\centering
	\begin{tabular}{ll}
	\toprule
 	Regel & Omschrijving \\ \midrule
 	Huidige presentatie & Er is ten alle tijden een presentatie open.\\
 	Minstens \1 slide & Om een presentatie weer te kunnen geven, moet er ten \\& minste \1 slide aanwezig zijn in de presentatie.\\
 	Level van items & Level 1 items zijn de root items. Hogere levels zijn \\& onderliggende items van level 1 items.\\
 	Volgende slide & De volgende slide is alleen beschikbaar wanneer alle items \\& zichtbaar zijn en er een volgende slide beschikbaar is.\\
 	Vorige slide & De vorige slide is alleen beschikbaar wanneer alleen de \\& titel zichtbaar is en er een vorige slide beschikbaar is.\\
 	Specifieke slide & Er kan alleen naar een specifieke slide genavigeerd worden \\& wanneer er een geldige slidenummer is opgegeven.\\
 	Level bepalend & Het level van een element bepaalt wie de ouder van dat \\& element is. Hoe hoger het level, hoe dieper de structuur.\\
  	\bottomrule
	\end{tabular}
\caption{Lijst van regels binnen het domein.}
\label{table:regels}
\end{table}


Texten in een Presentatie hebben een bepaalde stijl.

Er is een vaste set voorgedefinineerde stijlen.

Er is altijd maar 1 presentatie actief in jabberpoint.

De gebruiker kan niet terug navigeren bij de eerste slide.

De gebruiker kan niet vooruit navigeren bij de laatste slide.

Als er geen bestandsnaam is opgegeven wordt er een Demo Presentatie geopend.

Stijl van een text in een slide bepaald:
\begin{itemize}
    \item Kleur
    \item Font
    \item Lettergrootte
    \item Indentatie
    \item Lead (afstand tot regel er voor)
\end{itemize}

Omgekeerd bij het terug gaan zal naar de vorige slide worden gegaan welke
volledig getoond wordt met alle elementen.

Wanneer gebruikt gemaakt wordt van navigatie om direct naar een vorige of
volgende slide te gaan, dan wordt de slide in being status getoond.

\subsection{Gewenste Update}
\todo{Kopje verder uitwerken, lopende zinnen maken}

Er is ook een verzoek voor het aanpassen van gedrag in de applicatie. Deze geeft
de volgende aanpassingen in de Probleemanalyse:

Acties: De gebruiker kan per element naar voren gaan in de huidige slide.

Regels: Wanneer alle elementen getoond worden van een slide, dan zal de volgende
'element' naar de volgende slide gaan.

De update voegt geen nieuwe dingen toe aan het ontwerp.

\section{Ontwerp}
\label{sec:ontwerp}
\todo{Hier heb ik nu deels uitleg staan, maar ook suggesties en ideeen waar
Gerralt nog naar moet kijken. Design is ook nog niet af, needs input.}
\\
\todo{Goed kijken naar dit hoofdstuk}
\\
\todo{Meer TODO's maken voor suggesties JJ richting Gerralt}

\subsection{CommandFacade}
MenuController en KeyController bieden beiden de mogelijkheid om commando's aan
de applicatie te geven. De Facade is de centrale plek waar deze commando's
worden verzameld. De Facade zal de juiste onderdelen aanroepen om de commando's
uit te voeren.

\subsection{Presentation}
JabberPoint laat altijd maar 1 presentatie tegelijk zien.

Voorstel aan Gerralt: Er is ten alle tijden altijd maar 1 Presentatie Object.
Daarnaast is het even de vraag of Presentation de SlideViewerComponent update,
of dat SlideViewerComponent om een update aan Presentation vraagt. ben momenteel
voor de eerste.

Als Presentation een Singleton is kan deze ook de call doen om een bestand te
openen. Deze wordt gedelegeerd aan wat ik nu de FileHandler noem. Deze zal
waarschijnlijk Bridge gebruiken om te bepalen hoe een bestand geparsed moet
worden.

Verder zal er wellicht een generator voor Slides moeten komen. Deze
verantwoordelijkheid aan Presentation geven is misschien niet verstandig.

Alternatief: Er komt een PresentationController welke mogelijk meerdere
presentation kan beheren en bijhoud wat de huidige presentatie is. Dit is
hooguit handig als er in de toekomst een mogelijkheid moet komen om meerdere
presentatie tegelijk te openen (waar de interface niet op ingesteld is). Maar is
niet conform de huidige eisen.

\subsubsection{Slide}
Een presentatie bevat een X aantal Slides. Elke Slide bestaat uit een X aantal
Slide Items. Conform de text.xml heeft een Slide een default stijl (genaamd
level in de XML), en elk element kan een apparte stijl krijgen (of dus de
default gebruiken).

Style is dus meer een strategy Patroon dat afhankelijk van de ingestelde level
het renderen wordt aangepast bij het terug gegeven.

Het is even kijken hoe JFrame dingen doet, daar heb ik te weinig ervaring mee.
Het liefst wil je namelijk dat ze dingen terug geven door de keten heen naar
Presentatie die de update uitvoert.

\subsection{Scheiding}
Primaire doel is dingen in zoveel mogelijk losse componenten op te delen.
Vooral verwerking van weergave scheiden.

\section{Keuzen}
\todo{Gemaakte keuzen verantwoorden op twee gebieden: Ontwerp en Implementatie}


\section{Sourcecode}
\label{sec:source}
\todo{Sourcecode nader beschrijven}
\\
\todo{Proces van refactoring beschrijven}
\\
\todo{Proberen waar we tegen aan liepen beschrijven}

\end{document}
