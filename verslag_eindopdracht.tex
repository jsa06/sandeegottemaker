\documentclass[a4paper]{article}

\usepackage{xcolor}
\usepackage{fancyheadings}


\newcommand{\todo}[1]{\textcolor{red}{[#1]}}
\lhead{Open Universiteit}
\chead{IM0102, Design patterns}
\rhead{Eindopdracht}

\begin{document}
\pagestyle{fancy}

\section*{Studentgegevens}
\begin{description}
	\item [Cursuscode] IM0102
	\item JabberPoint
    \item Jan Jaap Sandee --- 852025385
	\item Gerralt Gottemaker --- 852083852
\end{description}
\todo{Verslag op taal- en spellingsfouten controleren}

\section*{Aanpak}
Om de opdracht succesvol af te ronden, is het zaak om goed samen te werken. We hebben het geluk collega's te zijn, wat het communiceren een aanzienlijk stuk gemakkelijker maakt. In dit hoofdstuk staat de aanpak beschreven die we gekozen hebben. De volgorde waarin het opgeschreven is, is ook de volgorde waarin we gewerkt hebben. Verder staat per item beschreven wie hieraan gewerkt heeft. Als niet vermeld wordt wie eraan gewerkt heeft, hebben beide teamgenoten eraan gewerkt.

Er is begonnen met het opzetten van een Git repository waarin Jan Jaap Gerralt en beide examinatoren heeft toegevoegd. Hier is vervolgens de beginsituatie van JabberPoint toegevoegd. Even later is hier ook een begin van het verslag en een TODO lijst aan toegevoegd. Het verslag is toegevoegd omdat het een LaTeX bestand is, welke prima door versiebeheer beheerd kan worden. Verder heeft Gerralt een Google Drive folder gemaakt en Jan Jaap uitgenodigd. Hier zullen diagrammen (met Draw.io) en andere belangrijke bestanden die niet geschikt zijn voor Git versiebeheer worden bijgehouden.

Hierna heeft Jan Jaap een eenvoudig diagram gemaakt van de huidige situatie van JabberPoint. Dit geeft een duidelijker beeld van de pijnpunten en maakt de geplande refactoring overzichtelijker.

Vervolgens is er een Probleem Analyse gemaakt waarbij alleen is gekeken naar de functionaliteit van het systeem. De zogenaamde Mankala aanpak staat hierbij centraal. Gedurende het maken van de analyse is nog niet gekeken naar bestaande code van JabberPoint, om zo vooroordelen uit te sluiten. Hier is bewust voor gekozen omdat we het idee hebben dat het zo gemakkelijker is om te denken in termen van het domein en niet direct te denken in klassenamen. Jan Jaap heeft hiervan het opzetje gemaakt, welke vervolgens uitgebreid is door Gerralt. Hierna is samen gewerkt aan de uiteindelijke versie van de probleemanalyse.

Aan de hand van de probleemanalyse is een klassendiagram opgebouwd. Hierbij zijn de principes die genoemd worden in het tekstboek gevolgd, waarbij erg gelet is op het principe dat patterns de context creÃ«ren van onderliggende patterns. De design principes zoals high cohesion en low coupling staan hierbij natuurlijk ook centraal. In het verslag zijn vervolgens de verschillende (belangrijke) classes en structuren toegelicht.
\\\\
\todo{Aanpak keuzen verantwoorden}
\\
\todo{Aanpak implementatie verantwoorden}


\section{Probleemanalyse}
Om JabberPoint goed te kunnen refactoren, is een probleemanalyse van de casus gemaakt. Deze probleemanalyse is op basis van de Mankala aanpak gedaan. Deze aanpak bestaat uit een aantal stappen, welke een steeds duidelijker beeld van het domein moeten opleveren. In de volgende koppen staan deze stappen uitgewerkt.

\subsection{Dingen}
\todo{Lijst in tabel zetten voor overzicht. Template voor tabel halen uit verslag Gerralt opdr 1}

Er is een Presentatie, deze heeft Slides, en elke Slide heeft een aantal
elementen welke kunnen bestaan uit text of een afbeelding.

Texten in een Presentatie hebben een bepaalde stijl.

Er is een menu, welke een aantal acties voor de gebruiker heeft.

Er is een Frame waarin de presentatie getoond wordt.

Er is een vaste set voorgedefinineerde stijlen.

\subsection{Regels}
\todo{Voor elke actie een aantal vragen beantwoorden. Zie aanpak Mankala / verslag Gerralt opdr 1}

Er is altijd maar 1 presentatie actief in jabberpoint.

De gebruiker kan niet terug navigeren bij de eerste slide.

De gebruiker kan niet vooruit navigeren bij de laatste slide.

Als er geen bestandsnaam is opgegeven wordt er een Demo Presentatie geopend.

Stijl van een text in een slide bepaald:
\begin{itemize}
    \item Kleur
    \item Font
    \item Lettergrootte
    \item Indentatie
    \item Lead (afstand tot regel er voor)
\end{itemize}

Omgekeerd bij het terug gaan zal naar de vorige slide worden gegaan welke
volledig getoond wordt met alle elementen.

Wanneer gebruikt gemaakt wordt van navigatie om direct naar een vorige of
volgende slide te gaan, dan wordt de slide in being status getoond.

\subsection{Acties}
\todo{Lijst in tabel zetten voor overzicht. Template voor tabel halen uit verslag Gerralt opdr 1}

De gebruiker kan een bestand openen met daarin een presentatie.

De gebruiker kan naar de volgende en vorige slides gaan.

Het menu bevat de volgende acties:
\begin{itemize}
    \item Open: Opent een bestand.
    \item New: Maak een nieuwe presentatie.
    \item Save: Sla de huidige presentatie op.
    \item Exit: Sluit het programma af.
    \item Prev: Ga naar Vorige Slide in huidige presentatie.
    \item Next: Ga naar volgende slide in huidige presentatie.
    \item Goto: Ga naar slide nummer X.
    \item About: Laat een informatie scherm van het programma zien.
\end{itemize}
Hierbij moet worden opgemerkt dat in de huidige versie Open altijd de demo
Presentatie opent. New een leeg scherm geeft zonder mogelijkheden iets aan te
passen, en Save geen feedback geeft van succes.

\subsection{Gewenste Update}
\todo{Kopje verder uitwerken, lopende zinnen maken}

Er is ook een verzoek voor het aanpassen van gedrag in de applicatie. Deze geeft
de volgende aanpassingen in de Probleemanalyse:

Acties: De gebruiker kan per element naar voren gaan in de huidige slide.

Regels: Wanneer alle elementen getoond worden van een slide, dan zal de volgende
'element' naar de volgende slide gaan.

De update voegt geen nieuwe dingen toe aan het ontwerp.

\section{Ontwerp}
\todo{Hier heb ik nu deels uitleg staan, maar ook suggesties en ideeen waar
Gerralt nog naar moet kijken. Design is ook nog niet af, needs input.}
\\
\todo{Goed kijken naar dit hoofdstuk}
\\
\todo{Meer TODO's maken voor suggesties JJ richting Gerralt}

\subsection{CommandFacade}
MenuController en KeyController bieden beiden de mogelijkheid om commando's aan
de applicatie te geven. De Facade is de centrale plek waar deze commando's
worden verzameld. De Facade zal de juiste onderdelen aanroepen om de commando's
uit te voeren.

\subsection{Presentation}
JabberPoint laat altijd maar 1 presentatie tegelijk zien.

Voorstel aan Gerralt: Er is ten alle tijden altijd maar 1 Presentatie Object.
Daarnaast is het even de vraag of Presentation de SlideViewerComponent update,
of dat SlideViewerComponent om een update aan Presentation vraagt. ben momenteel
voor de eerste.

Als Presentation een Singleton is kan deze ook de call doen om een bestand te
openen. Deze wordt gedelegeerd aan wat ik nu de FileHandler noem. Deze zal
waarschijnlijk Bridge gebruiken om te bepalen hoe een bestand geparsed moet
worden.

Verder zal er wellicht een generator voor Slides moeten komen. Deze
verantwoordelijkheid aan Presentation geven is misschien niet verstandig.

Alternatief: Er komt een PresentationController welke mogelijk meerdere
presentation kan beheren en bijhoud wat de huidige presentatie is. Dit is
hooguit handig als er in de toekomst een mogelijkheid moet komen om meerdere
presentatie tegelijk te openen (waar de interface niet op ingesteld is). Maar is
niet conform de huidige eisen.

\subsubsection{Slide}
Een presentatie bevat een X aantal Slides. Elke Slide bestaat uit een X aantal
Slide Items. Conform de text.xml heeft een Slide een default stijl (genaamd
level in de XML), en elk element kan een apparte stijl krijgen (of dus de
default gebruiken).

Style is dus meer een strategy Patroon dat afhankelijk van de ingestelde level
het renderen wordt aangepast bij het terug gegeven.

Het is even kijken hoe JFrame dingen doet, daar heb ik te weinig ervaring mee.
Het liefst wil je namelijk dat ze dingen terug geven door de keten heen naar
Presentatie die de update uitvoert.

\subsection{Scheiding}
Primaire doel is dingen in zoveel mogelijk losse componenten op te delen.
Vooral verwerking van weergave scheiden.

\section{Keuzen}
\todo{Gemaakte keuzen verantwoorden op twee gebieden: Ontwerp en Implementatie}


\section{Sourcecode}
\todo{Sourcecode nader beschrijven}
\\
\todo{Proces van refactoring beschrijven}
\\
\todo{Proberen waar we tegen aan liepen beschrijven}

\end{document}
